## Introduce

从较高层次看，两种模式很类似。
它们力争把用户界面、业务逻辑、数据层分开，即分离关注，使UI更容易变换和单元测试。
任何应用程序架构的目标都是使代码尽可能地可测试。
在任何应用程序中，UI都特别地难以测试。因此，我们试图**把逻辑从视图中剥离出来**，由此实现代码可测试的目标。

**MVC模式**

 1. Controller 接受用户输入（User Action）
 2. Controller 操作 Model 进行数据更新
 3. Model 返回的数据直接用来渲染 View
 4. 客户端显示更新后的 View

在MVC模式中，程序认为 View 是无状态的。
因此用户输入等价于HTTP请求，用户输入由服务端进行数据处理和响应，HTTP请求由后端 Controller 来接管。
Controller 并不知道 View 的任何细节（面向HTTP接口），Controller 和 View 是一对多的关系。

**MVVM模式**

 1. The user provides some kind of input.
 2. The View translates this to data and sends this data to the ViewModel, the ViewModel holds the data.
 3. When called to do so with a command, the ViewModel forwards the data as changes to the model.
 4. The Model is updated and sends possibly notifications of its state back to the ViewModel.
 5. The ViewModel sends a notification back to the View and the View rerenders.

**The behavior and state is put in the Presentation Model.**
That means, the view itself will not keep any state.
The Presentation Model contains the state.

## original

It really boils down to just the difference between the early web and the desktop.The first acronym, MVC, originated on the web.
Let's retain one feature of this web stuff, not as it is today, but as it existed ten years ago.
The HTML page is essentially dumb and passive. The browser is a thin client, or if you will, a poor client. There is no intelligence in the browser.
Full page reloads rule. The »view« is generated anew each time around.

----------

Desktop apps are fat clients, or rich clients. They're clients full of intelligence, **full of knowledge about their data**.
They're **stateful**. They cache data they're handling in memory. No such crap as a full page relaod.
And this rich desktop way is probably where the second acronym originated, MVVM.
Don't be fooled by the letters, by the omission of the C. Controllers are still there. They need to be. Nothing gets removed.
We just add one thing: **statefulness, data cached on the client (and along with it intelligence to handle that data)**.
That data, essentially a cache on the client, now gets called **»ViewModel«**. It's what allows rich interactivity. And that's it.

> MVC = model, controller, view

> MVVM = model, controller（User Action）, cache（User Data）, view

We can see that with Javascript, the web has embraced MVVM.


## 其他文章

[Understanding MVC, MVP and MVVM Design Patterns](http://www.dotnet-tricks.com/Tutorial/designpatterns/2FMM060314-Understanding-MVC,-MVP-and-MVVM-Design-Patterns.html)

> In web application, each action is a call to a URL and for each such call there is a controller available in the application who respond to such call. Once that Controller has completed its processing, it will return the correct View.