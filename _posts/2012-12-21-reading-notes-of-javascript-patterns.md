《JavaScript Patterns》读书笔记

书非常好，但翻译不够到位。如果有条件，推荐读英文原版。

另，关于写读书笔记的想法，这里说明一二。之前自己喜欢一边看书一边做笔记，但发现这样对整本书的知识体系梳理以及自己对全书的思考和理解不足，知识点之间的联系比较松散。有鉴于此，今后的读书笔记应该分为两类，一是知识梳理，旨在建立知识体系，加强知识点间的相互联系，加深对知识的理解；二是思考反思，旨在通过自己的语言来描述书中知识，思考书本的组织方式，书的最终目的，通过思考和反思，将知识转化为己用。

话不多说，开始知识梳理重点。主要是跟据目录来适当展开叙述。

第一章 简介

- 什么是模式？
- JavaScript的基本概念
- ECMAScript 5

第二章 基本技巧

- 编写可维护的代码，我们的目标
- 尽量减少全局变量：避免全局环境的污染
- 不要增加内置类型的原型方法，降低理解成本
- 使用 === 和 !==
- always parseInt(num, 10)
- 编码风格约定：缩进、大括号、空格
- 命名约定：构造函数、单词分隔符约定、私有成员、全局变量与常量
- 编写注释
- 编写 API 文档: 非常好的编码实践
- 编写可读性强的代码
- code review

第三章 字面量和构造函数

- 强制使用 new，不做兼容处理
- 正则表达式字面量 regexp = /[a-z]sojuker$/ig
- 标准化错误对象和错误处理，try-throw-catch， error.name && error.message

第四章 函数 Function

- 函数是第一类对象，并且可执行并提供了作用域。
- 函数表达式、函数声明 两者的区别和用处
- 函数命名属性：name，便于调试
- 高阶函数，能通过创造有限访问权限的中间作用域，实现私有变量，Curry 柯里化等很多有趣功能
- 立即执行函数 (function (win){ ... })(window)，避免污染
- 初始化分支模式：用于特性检测时有诸多的应用
- 函数静态属性，用于实现缓存

第五章 对象创建模式

- 命名空间模式：namespace("MYAPP.util.aaa");
- 声明依赖关系：在函数的头部集中声明依赖
- 实现私有属性和方法
- 特权方法访问的私有属性是一个对象时，依据最低授权原则或者复制对象返回副本。
- 模块模式：返回一个 util
- 构造函数模式：最后返回一个构造函数而不是对象

第六章 代码复用模式

- 原型式继承和借用构造函数模式相互结合。
- 子类中存放用于访问父类的指针（uber属性）。
- 非类式继承实践：
    - 原型式继承和ECMA5实现——Object.create(o)
    - 浅/深复制
    - 混入模式，实现对象属性和方法的拓展

第七章 设计模式

- 单体模式： 单体类仅能创建一个独一无二的对象。
- 工厂模式： 用于间接地创建实例，实际上是提供一个便利方法来创建实例。
- 迭代器模式： 提供API来遍历或者操作复杂的自定义数据结构，简化数据的遍历和读写操作。
- 装饰者模式： 装饰者按照一定的排列顺序来装饰原始数据，并形成最后的数据。
- 策略模式： 不同上下文情况下返回不同的 subClass ， 这些 subClass 实现了相同的Interface，因此对外暴露了同名API，而API的内部实现则对开发者是透明的。比如 Validator 校验器可以使用这个功能来校验不同类型的数据。
- 外观模式： 通过把几个经常连续调用的方法包装到一个新方法中，提供更便利的API，使业务逻辑更加清晰。外观模式在重构中也有着不错的应用，能适应版本迭代的需要。
- 代理模式： 通过包装一个对象以控制对它的访问，其主要方法是将访问聚集为组（批量）或者仅当真正必要的时候才执行访问，从而避免高昂的操作开销。这个情形下，本体对象的操作开销非常大，通过代理来尽量避免对本体对象的操作开销，还可以在代理对象中建立缓冲区，用于存放本体对象的执行结果，避免重复操作而加大开销。
- 中介者模式： 您的对象间并不直接通信，而必须通过中介者对象进行通信，从而促进松散耦合，独立业务逻辑。是大型程序开发中一个非常优秀的设计模式，中介者粘合各个具体模块，实现主流程业务逻辑。
- 观察者模式： 通过创建可观察的对象（发布者），当发生一个感兴趣的事件时可以将该事件通知给所有订阅该事件的观察者，从而形成松散耦合，但业务逻辑被解构到各个对象内部，程序可读性减低。