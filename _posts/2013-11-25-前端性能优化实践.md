> under reivew

最近这段时间在做自己产品线上的性能优化，通过这段时间的调研和实践，不仅温习了不少的知识，也同时深刻认识了更多性能优化的细节与实现方法。

先来说这次性能优化优化了哪些方面。

## 1、减少页面依赖资源的大小。

从这个角度出发，首先是 减少代码的冗余量。为了尽可能地降低性能优化的项目风险，这次优化的出发点是尽可能避免对业务逻辑代码的优化，只做系统级代码的优化。主要回顾点是全站通用的CSS样式。

第二个减少资源大小的方法是对资源进行压缩（HTML、CSS、JS、图片）。如HTML，我们可以去干掉其中的空白符（+注释），这使用Smarty本身的压缩功能就已经实现。比如CSS的压缩，也是主要是干掉文件中的空白符和注释，这个使用在线工具进行压缩。从开发自动化角度看，我们希望这个压缩是无感知的、自动化的，比如使用grunt来实现自动化压缩。比如JavaScript的压缩，除正常的压缩外，还有JS的混淆，这也有提升的空间。在这个方面，也有一些在线资源可以支持，同时grunt也对应的插件支持。最后一点，还有图片资源的压缩。图片压缩是这次优化的重点，因为对HTML、CSS、Js的压缩，我们的开发平台上已经自动化集成了，但图片压缩做的不是很好，之前在开发中也没有注意到，所以这次会集中对图片进行压缩，之后的项目维护就需要各自进行图片压缩。在对于图片格式上的选择，CSS中图片一般是使用png格式，现在发现PNG32经过压缩后的大小也是可以接受的（因为没有索引信息，所以可能小图片相差不大，还没有具体对比数据）。对复杂图片还是坚持使用jpeg，PNG图片存储大图片还是不太给力（因为PNG是无损压缩格式）。

第三个减少资源大小在于传输时使用压缩编码，比如常用的gzip，这个需要在服务器开启这个编码，我们之间的系统已经使用这个配置，所以不需再进行处理。

第四，干掉无用的Cookie。将对后端透明的信息统一使用前端的本地存储来实现，减少数据的传输量。

## 2、减少HTTP请求
减少HTTP请求方面，我也做了一些观察和研究，也有几个思路。

第一个使用缓存，最近steveshould（一定是记错了）写了一篇《缓存为王》的文章。还没有仔细看过，但是从这个意思上来说，缓存是非常NB的。但是，一般而言，“缓存原则”和下面我说的“请求合并”是相互冲突的，具体场景下还是要做权衡，这方面个人感觉还是需要深入的调研，实际测试才算好。因为HTTP这个方面自己理解上不够深入彻底。缓存这个东西也比较复杂，有校验、本地过期、代理服务器缓存~~~~一个一个的，还有HTTP2的，你妹的要研究起来又是一个大坑啊。

第二个就说说请求合并，也就是把多个请求合并为一个请求来请求。因为对网页来说，都是小数据传输，这个时候服务器的TCP连接，或者再加SSL，这个连接时间（还有请求往返时间）实际上非常浪费带宽的。另外，合并请求对于单个页面来说或许减少了HTTP请求，但是对于整个站点来说，这就不一定了。由于不同页面之间可以存在一些共用的资源，如何使得这些公用资源更好地缓存，从而减少所需资源的大小，这也是非常关键的一点。我们这次优化也会单独去梳理请求的合并打包策略，看如何才能更好地降低用户下载资源的时间。

第三个是内联请求。比如内联的CSS、内联的JS、内联的图片（svg、canvas、base64），对吧，内联请求最关键的不需要增加HTTP请求了。内联技术有一个很大的问题，就是难以被缓存，这是其致命的缺陷。此外，内联技术的使用会对真正用户关注的信息延迟展现，这对用户来说也是不好的。比如内联JS会阻塞HTML的解析工作，会有可能延迟页面的展现。一般而言，我们需要关注用户的当前屏幕，先展示信息，然后再提供功能。在空闲的时间，在后台跑一些程序为将来做准备。

第四个，移动端的挑战和机遇。iphone系统，允许缓存资源的大小不能操作25KB，否则该资源无法缓存下来，最新的IOS系统还把这个阈值降低到了15KB。对于webapp来说，这是一个很大的挑战，为了更好地迎接这个挑战，也有新的技术被提出，这就是离线技术，使用manifest。不过manifest根据调研结果来看，不利于维护，特别是对于迭代很频繁的webapp来说，如果没有自动化的维护，维护一套manifest将是一个噩梦。因此，这个性能优化中，我们暂时没有考虑采用这个技术。

## 3、计算性能
上面讨论的主要还是网络传输上的传输性能。而下面讨论计算性能。这个方面，有

- 高效HTML
- 高效JavaScript
- base64解码性能，webP解码性能这么一些

由于这些比较高深，也不多说。

## 4、其他

- CDN接入
- 避免302重定向
- 注意资源的顺序，CSS在前。
- 图片大小最好不要冗余（也算是冗余的一部分了）
- 使得AJAX缓存（这个做了一个，后续再看了）
- 移动端面对webkit内核开发，只需要兼容一个内核，所以可以干掉很多兼容性能代码
- 服务器 flush 内容（我们的架构好像不允许我们这样做）
- balabala~~~~~~~